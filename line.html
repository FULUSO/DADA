import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';
import { motion } from 'framer-motion';

// --- 多國語言翻譯 ---
const translations = {
    'zh-TW': {
        title: 'One Click Sticker V3',
        subtitle: '將您的照片變成獨一無二的聊天貼圖。',
        upload_title: '1. 您的照片',
        upload_click: '點擊以上傳檔案',
        upload_or: '或',
        upload_camera: '使用相機',
        upload_change_file: '更換檔案',
        stickers_title: '2. 選擇貼圖',
        generator_title: '✨ AI 貼圖創意產生器',
        generator_desc: '描述一個主題，或讓 AI 從您的照片找靈感！',
        generator_inspiration_btn: '從圖片取得靈感',
        generator_analyzing: '分析中...',
        generator_placeholder: '例如：我家愛搗蛋的橘貓、辦公室專用...',
        generator_generate_ideas_btn: '產生點子',
        generator_generating: '產生中...',
        select_reactions: '選擇您想生成的反應：',
        back_to_default: '← 返回預設貼圖',
        option_anime: '可愛動漫',
        option_add_text: '加上文字',
        option_dynamic_preview: '動態預覽',
        generate_stickers_btn: '生成貼圖',
        generating_stickers: '生成中...',
        remove_bg_btn: '一鍵去背',
        removing_bg: '去背中...',
        remove_bg_desc: '智能去除亮綠色背景，保留人物細節',
        your_generated_stickers: '您生成的貼圖',
        keep_window_open: '生成貼圖時請保持此視窗開啟。',
        start_over: '重新開始',
        download_zip: '打包下載',
        zipping: '打包中...',
        error_upload: '請先上傳一張照片！',
        error_select_one: '請至少選擇一個貼圖來生成！',
        error_zip_lib: '壓縮程式庫尚未載入，請稍後再試。',
        error_no_stickers_to_zip: '沒有可以打包的貼圖。',
        error_zip_failed: '建立壓縮檔失敗，請再試一次。',
        error_no_stickers_to_process: '沒有可以處理的貼圖。',
        error_bg_remove_failed: '去背處理失敗，請再試一次。',
        error_ideas_input: '請輸入您的貼圖點子描述！',
        error_ideas_failed: '無法產生貼圖點子，請稍後再試。',
        error_inspiration_failed: '無法從圖片取得建議，請稍後再試。',
        error_regenerate_failed: '為 "{stickerName}" 重新生成失敗。',
        footer_portals: '無限世界',
        footer_resources: '社群應用資源',
        footer_chat: '無限聊天群',
        sticker_happy: '開心',
        sticker_sad: '傷心',
        sticker_laugh: '大笑',
        sticker_angry: '生氣',
        sticker_love: '愛心',
        sticker_ok: 'OK',
        sticker_confused: '問號',
        sticker_sleepy: '想睡',
        sticker_surprised: '驚訝',
        sticker_thinking: '思考',
        sticker_crying: '難過',
        sticker_pleading: '拜託',
    },
    'zh-CN': {
        title: '一键贴纸 V3',
        subtitle: '将您的照片变成独一无二的聊天贴图。',
        upload_title: '1. 您的照片',
        upload_click: '点击以上传文件',
        upload_or: '或',
        upload_camera: '使用相机',
        upload_change_file: '更换文件',
        stickers_title: '2. 选择贴图',
        generator_title: '✨ AI 贴图创意生成器',
        generator_desc: '描述一个主题，或让 AI 从您的照片找灵感！',
        generator_inspiration_btn: '从图片获取灵感',
        generator_analyzing: '分析中...',
        generator_placeholder: '例如：我家爱捣蛋的橘猫、办公室专用...',
        generator_generate_ideas_btn: '生成点子',
        generator_generating: '生成中...',
        select_reactions: '选择您想生成的反应：',
        back_to_default: '← 返回预设贴图',
        option_anime: '可爱动漫',
        option_add_text: '加上文字',
        option_dynamic_preview: '动态预览',
        generate_stickers_btn: '生成贴图',
        generating_stickers: '生成中...',
        remove_bg_btn: '一键去背',
        removing_bg: '去背中...',
        remove_bg_desc: '智能去除亮绿色背景，保留人物细节',
        your_generated_stickers: '您生成的贴图',
        keep_window_open: '生成贴图时请保持此窗口开启。',
        start_over: '重新开始',
        download_zip: '打包下载',
        zipping: '打包中...',
        error_upload: '请先上传一张照片！',
        error_select_one: '请至少选择一个贴图来生成！',
        error_zip_lib: '压缩程序库尚未加载，请稍后再试。',
        error_no_stickers_to_zip: '没有可以打包的贴图。',
        error_zip_failed: '建立压缩文件失败，请再试一次。',
        error_no_stickers_to_process: '没有可以处理的贴图。',
        error_bg_remove_failed: '去背处理失败，请再试一次。',
        error_ideas_input: '请输入您的贴图点子描述！',
        error_ideas_failed: '无法产生贴图点子，请稍后再试。',
        error_inspiration_failed: '无法从图片获取建议，请稍后再试。',
        error_regenerate_failed: '为“{stickerName}”重新生成失败。',
        footer_portals: '无限世界',
        footer_resources: '社群应用资源',
        footer_chat: '无限聊天群',
        sticker_happy: '开心',
        sticker_sad: '伤心',
        sticker_laugh: '大笑',
        sticker_angry: '生气',
        sticker_love: '爱心',
        sticker_ok: 'OK',
        sticker_confused: '问号',
        sticker_sleepy: '想睡',
        sticker_surprised: '惊讶',
        sticker_thinking: '思考',
        sticker_crying: '难过',
        sticker_pleading: '拜托',
    },
    'en': {
        title: 'One Click Sticker V3',
        subtitle: 'Turn your photos into unique chat stickers.',
        upload_title: '1. Your Photo',
        upload_click: 'Click to upload a file',
        upload_or: 'or',
        upload_camera: 'Use Camera',
        upload_change_file: 'Change File',
        stickers_title: '2. Choose Stickers',
        generator_title: '✨ AI Sticker Idea Generator',
        generator_desc: 'Describe a theme, or let AI get inspired by your photo!',
        generator_inspiration_btn: 'Get Inspired by Photo',
        generator_analyzing: 'Analyzing...',
        generator_placeholder: 'e.g., My naughty orange cat, office life...',
        generator_generate_ideas_btn: 'Generate Ideas',
        generator_generating: 'Generating...',
        select_reactions: 'Select the reactions you want to generate:',
        back_to_default: '← Back to Default',
        option_anime: 'Cute Anime',
        option_add_text: 'Add Text',
        option_dynamic_preview: 'Dynamic Preview',
        generate_stickers_btn: 'Generate Stickers',
        generating_stickers: 'Generating...',
        remove_bg_btn: 'Remove BG',
        removing_bg: 'Removing...',
        remove_bg_desc: 'Intelligently removes the bright green background.',
        your_generated_stickers: 'Your Generated Stickers',
        keep_window_open: 'Please keep this window open while stickers are generating.',
        start_over: 'Start Over',
        download_zip: 'Download ZIP',
        zipping: 'Zipping...',
        error_upload: 'Please upload a photo first!',
        error_select_one: 'Please select at least one sticker to generate!',
        error_zip_lib: 'Zipping library not loaded yet, please try again later.',
        error_no_stickers_to_zip: 'No stickers available to zip.',
        error_zip_failed: 'Failed to create ZIP file, please try again.',
        error_no_stickers_to_process: 'No stickers available to process.',
        error_bg_remove_failed: 'Background removal failed, please try again.',
        error_ideas_input: 'Please enter a description for your sticker idea!',
        error_ideas_failed: 'Failed to generate sticker ideas, please try again later.',
        error_inspiration_failed: 'Failed to get suggestions from the image, please try again later.',
        error_regenerate_failed: 'Failed to regenerate for "{stickerName}".',
        footer_portals: 'Infinite Worlds',
        footer_resources: 'Community Resources',
        footer_chat: 'Infinite Chat',
        sticker_happy: 'Happy',
        sticker_sad: 'Sad',
        sticker_laugh: 'Laugh',
        sticker_angry: 'Angry',
        sticker_love: 'Love',
        sticker_ok: 'OK',
        sticker_confused: 'Confused',
        sticker_sleepy: 'Sleepy',
        sticker_surprised: 'Surprised',
        sticker_thinking: 'Thinking',
        sticker_crying: 'Crying',
        sticker_pleading: 'Pleading',
    },
    'ja': {
        title: 'ワンクリックステッカー V3',
        subtitle: 'あなたの写真をユニークなチャットスタンプに変えましょう。',
        upload_title: '1. あなたの写真',
        upload_click: 'クリックしてファイルをアップロード',
        upload_or: 'または',
        upload_camera: 'カメラを使用',
        upload_change_file: 'ファイルを変更',
        stickers_title: '2. スタンプを選択',
        generator_title: '✨ AIスタンプアイデア生成',
        generator_desc: 'テーマを説明するか、AIに写真からインスピレーションを得させましょう！',
        generator_inspiration_btn: '写真からインスピレーションを得る',
        generator_analyzing: '分析中...',
        generator_placeholder: '例：いたずら好きなオレンジ色の猫、オフィスライフ...',
        generator_generate_ideas_btn: 'アイデアを生成',
        generator_generating: '生成中...',
        select_reactions: '生成したいリアクションを選択してください：',
        back_to_default: '← デフォルトに戻る',
        option_anime: 'かわいいアニメ',
        option_add_text: 'テキストを追加',
        option_dynamic_preview: 'ダイナミックプレビュー',
        generate_stickers_btn: 'スタンプを生成',
        generating_stickers: '生成中...',
        remove_bg_btn: '背景を削除',
        removing_bg: '削除中...',
        remove_bg_desc: '明るい緑色の背景をインテリジェントに削除します。',
        your_generated_stickers: '生成されたスタンプ',
        keep_window_open: 'スタンプ生成中は、このウィンドウを開いたままにしてください。',
        start_over: '最初からやり直す',
        download_zip: 'ZIPをダウンロード',
        zipping: '圧縮中...',
        error_upload: 'まず写真をアップロードしてください！',
        error_select_one: '少なくとも1つのスタンプを選択してください！',
        error_zip_lib: '圧縮ライブラリがまだ読み込まれていません。後でもう一度お試しください。',
        error_no_stickers_to_zip: '圧縮できるスタンプがありません。',
        error_zip_failed: 'ZIPファイルの作成に失敗しました。もう一度お試しください。',
        error_no_stickers_to_process: '処理できるスタンプがありません。',
        error_bg_remove_failed: '背景の削除に失敗しました。もう一度お試しください。',
        error_ideas_input: 'スタンプのアイデアの説明を入力してください！',
        error_ideas_failed: 'スタンプのアイデアの生成に失敗しました。後でもう一度お試しください。',
        error_inspiration_failed: '画像から提案を取得できませんでした。後でもう一度お試しください。',
        error_regenerate_failed: '「{stickerName}」の再生成に失敗しました。',
        footer_portals: '無限世界',
        footer_resources: 'コミュニティリソース',
        footer_chat: '無限チャット',
        sticker_happy: '嬉しい',
        sticker_sad: '悲しい',
        sticker_laugh: '大笑い',
        sticker_angry: '怒り',
        sticker_love: '大好き',
        sticker_ok: 'OK',
        sticker_confused: '疑問',
        sticker_sleepy: '眠い',
        sticker_surprised: '驚き',
        sticker_thinking: '考え中',
        sticker_crying: '泣いてる',
        sticker_pleading: 'お願い',
    },
    'ko': {
        title: '원클릭 스티커 V3',
        subtitle: '당신의 사진을 독특한 채팅 스티커로 만드세요.',
        upload_title: '1. 당신의 사진',
        upload_click: '클릭하여 파일 업로드',
        upload_or: '또는',
        upload_camera: '카메라 사용',
        upload_change_file: '파일 변경',
        stickers_title: '2. 스티커 선택',
        generator_title: '✨ AI 스티커 아이디어 생성기',
        generator_desc: '테마를 설명하거나 AI가 사진에서 영감을 얻도록 하세요!',
        generator_inspiration_btn: '사진에서 영감 얻기',
        generator_analyzing: '분석 중...',
        generator_placeholder: '예: 장난꾸러기 주황색 고양이, 사무실 생활...',
        generator_generate_ideas_btn: '아이디어 생성',
        generator_generating: '생성 중...',
        select_reactions: '생성할 반응을 선택하세요:',
        back_to_default: '← 기본으로 돌아가기',
        option_anime: '귀여운 애니메이션',
        option_add_text: '텍스트 추가',
        option_dynamic_preview: '동적 미리보기',
        generate_stickers_btn: '스티커 생성',
        generating_stickers: '생성 중...',
        remove_bg_btn: '배경 제거',
        removing_bg: '제거 중...',
        remove_bg_desc: '밝은 녹색 배경을 지능적으로 제거합니다.',
        your_generated_stickers: '생성된 스티커',
        keep_window_open: '스티커를 생성하는 동안 이 창을 열어 두십시오.',
        start_over: '처음부터 다시 시작',
        download_zip: 'ZIP 다운로드',
        zipping: '압축 중...',
        error_upload: '먼저 사진을 업로드해주세요!',
        error_select_one: '생성할 스티커를 하나 이상 선택해주세요!',
        error_zip_lib: '압축 라이브러리가 아직 로드되지 않았습니다. 나중에 다시 시도해주세요.',
        error_no_stickers_to_zip: '압축할 스티커가 없습니다.',
        error_zip_failed: 'ZIP 파일 생성에 실패했습니다. 다시 시도해주세요.',
        error_no_stickers_to_process: '처리할 스티커가 없습니다.',
        error_bg_remove_failed: '배경 제거에 실패했습니다. 다시 시도해주세요.',
        error_ideas_input: '스티커 아이디어에 대한 설명을 입력해주세요!',
        error_ideas_failed: '스티커 아이디어를 생성하지 못했습니다. 나중에 다시 시도해주세요.',
        error_inspiration_failed: '이미지에서 제안을 가져오지 못했습니다. 나중에 다시 시도해주세요.',
        error_regenerate_failed: '"{stickerName}"에 대한 재성성에 실패했습니다.',
        footer_portals: '무한 세계',
        footer_resources: '커뮤니티 리소스',
        footer_chat: '무한 채팅',
        sticker_happy: '행복',
        sticker_sad: '슬픔',
        sticker_laugh: '웃음',
        sticker_angry: '화남',
        sticker_love: '사랑',
        sticker_ok: 'OK',
        sticker_confused: '물음표',
        sticker_sleepy: '졸림',
        sticker_surprised: '놀람',
        sticker_thinking: '생각 중',
        sticker_crying: '우는',
        sticker_pleading: '부탁',
    }
};

// --- 輔助函式 ---

const toBase64 = file => new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => resolve(reader.result);
    reader.onerror = error => reject(error);
});

const fetchWithRetry = (url, options, retries = 5, backoff = 1000) => {
    return new Promise((resolve, reject) => {
        const attempt = async (retryCount, delay) => {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('API 錯誤:', errorData);
                    if (response.status === 429 && retryCount > 0) {
                        console.log(`請求頻率過高。將在 ${delay / 1000} 秒後重試...`);
                        setTimeout(() => attempt(retryCount - 1, delay * 2), delay);
                    } else if (response.status === 401) {
                        reject(new Error(`API 請求失敗，狀態碼 401：未授權。請確認您的 API 金鑰是否有效。`));
                    }
                    else {
                        reject(new Error(`API 請求失敗，狀態碼 ${response.status}: ${errorData.error?.message || '未知錯誤'}`));
                    }
                } else {
                    resolve(response.json());
                }
            } catch (error) {
                if (retryCount > 0) {
                    console.log(`請求失敗。將在 ${delay / 1000} 秒後重試...`, error);
                    setTimeout(() => attempt(retryCount - 1, delay * 2), delay);
                } else {
                    reject(error);
                }
            }
        };
        attempt(retries, backoff);
    });
};

const generateImageWithRetry = async (payload, totalAttempts = 3) => {
    let lastError;
    for (let attempt = 1; attempt <= totalAttempts; attempt++) {
        try {
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
            const result = await fetchWithRetry(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
            if (base64Data) return `data:image/png;base64,${base64Data}`;
            lastError = new Error("API 未返回圖片資料。");
            console.warn(`第 ${attempt}/${totalAttempts} 次嘗試: ${lastError.message}`);
        } catch (error) {
            lastError = error;
            console.error(`第 ${attempt}/${totalAttempts} 次嘗試失敗:`, error);
        }
        if (attempt < totalAttempts) {
            const delay = 2500 * Math.pow(2, attempt - 1);
            await new Promise(res => setTimeout(res, delay));
        }
    }
    throw new Error(`圖片生成在 ${totalAttempts} 次嘗試後失敗。最後錯誤: ${lastError?.message || '未知錯誤'}`);
};

const removeBackground = (imageUrl) => {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i + 1], b = data[i + 2];
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                const delta = max - min;
                let hue = 0;
                if (delta !== 0) {
                    if (max === g) hue = 60 * ((b - r) / delta + 2);
                    else if (max === r) hue = 60 * ((g - b) / delta + 4);
                    else hue = 60 * ((r - g) / delta);
                }
                if (hue < 0) hue += 360;
                const saturation = max === 0 ? 0 : delta / max;
                const value = max / 255;
                const isGreenHue = (hue >= 60 && hue <= 180);
                const isHighSaturation = saturation > 0.3;
                const isBright = value > 0.4;
                const isGreenDominant = (g > r + 30 && g > b + 30);
                const pixelIndex = i / 4;
                const x = pixelIndex % canvas.width;
                const y = Math.floor(pixelIndex / canvas.width);
                const isEdgePixel = (x < 15 || x > canvas.width - 15 || y < 15 || y > canvas.height - 15);
                const isBackground = ( (isGreenHue && isHighSaturation && isBright) || (isEdgePixel && isGreenDominant && g > 100) || (g > 200 && r < 50 && b < 50) || (Math.abs(r - 0) < 20 && Math.abs(g - 255) < 20 && Math.abs(b - 0) < 20) );
                if (isBackground) data[i + 3] = 0;
            }
            ctx.putImageData(imageData, 0, 0);
            resolve(canvas.toDataURL('image/png'));
        };
        img.onerror = () => reject(new Error('圖片載入失敗'));
        img.src = imageUrl;
    });
};

const getModelInstruction = (prompt, addText, isAnimeStyle) => {
    if (isAnimeStyle) {
        let instruction = `Create a sticker in a cute, expressive Japanese anime/chibi style. It's very important to capture the likeness and key facial features of the person in the reference photo, but translated into this anime art style.
The sticker should represent the following action or emotion: "${prompt.base}".
The character should have large, expressive eyes and simplified features typical of chibi art.
The sticker MUST have a thick, clean white outline and a subtle drop shadow to make it pop.
The sticker MUST have a solid, bright lime green background (RGB: 0, 255, 0) - this is crucial for background removal later.
The final image should be a high-quality, sharp-focus PNG with vibrant colors.`;
        if (addText && prompt.memeText) {
            instruction += `\nAdditionally, incorporate the text "${prompt.memeText}" into the sticker design in a bold, cute, and readable English font that fits the anime style. The text should be easily visible.`;
        }
        return instruction;
    }
    let instruction = `The highest priority is to maintain the exact facial features, likeness, and perceived gender of the person in the provided reference photo.
Create a photorealistic, expressive, high-detail 1:1 aspect ratio chat sticker of the person, captured with a professional camera aesthetic. The sticker should represent the following action or emotion: "${prompt.base}".
The final image must look like a real photograph, not a cartoon or illustration.
The sticker MUST have a thick, clean white outline and a subtle drop shadow to make it pop.
The sticker MUST have a solid, bright lime green background (RGB: 0, 255, 0) - this is crucial for background removal later.
The final image should be a high-quality, sharp-focus PNG.
Do not alter the person's core facial structure or transform them into a 2D character.`;
    if (addText && prompt.memeText) {
        instruction += `\nAdditionally, incorporate the text "${prompt.memeText}" into the sticker design in a bold, clean, and readable English font that complements the realistic photo style. The text should be easily visible against the bright lime green background.`;
    }
    return instruction;
};

const getInspirationPrompt = (lang) => {
    const prompts = {
        'zh-TW': "分析這張圖片中的人物、表情、服裝以及任何顯著的物體或背景。根據你所看到的，為貼圖包建議3個有創意、簡短且有趣的主題。例如，如果你看到一隻貓，建議'貓奴日常'。如果你看到穿西裝的人，建議'辦公室風雲'。請以一個簡單的JSON字串陣列格式返回你的答案，例如 `[\"主題一\", \"主題二\", \"主題三\"]`。只返回JSON陣列。",
        'zh-CN': "分析这张图片中的人物、表情、服装以及任何显著的物体或背景。根据你所看到的，为贴图包建议3个有创意、简短且有趣的主题。例如，如果你看到一只猫，建议'猫奴日常'。如果你看到穿西装的人，建议'办公室风云'。请以一个简单的JSON字符串数组格式返回你的答案，例如 `[\"主题一\", \"主题二\", \"主题三\"]`。只返回JSON数组。",
        'en': "Analyze the person, their expression, clothing, and any notable objects or background in this image. Suggest 3 creative, short, and fun themes for a sticker pack based on what you see. For example, if you see a cat, suggest 'Cat Lover Life'. If you see someone in a suit, suggest 'Office Drama'. Return your answer as a simple JSON array of strings, like `[\"Theme One\", \"Theme Two\", \"Theme Three\"]`. Only return the JSON array.",
        'ja': "この画像の中の人物、表情、服装、そして目立つ物や背景を分析してください。見たものに基づいて、ステッカーパックのための創造的で短く、楽しいテーマを3つ提案してください。例えば、猫を見たら「猫好きの日常」、スーツを着た人を見たら「オフィスドラマ」などを提案してください。答えは `[\"テーマ1\", \"テーマ2\", \"テーマ3\"]` のような単純なJSON文字列配列として返してください。JSON配列のみを返してください。",
        'ko': "이 이미지의 인물, 표정, 의상 및 눈에 띄는 물체나 배경을 분석하십시오. 본 것을 바탕으로 스티커 팩에 대한 창의적이고 짧고 재미있는 테마 3가지를 제안하십시오. 예를 들어, 고양이를 보면 '고양이 집사의 일상'을 제안하고, 정장을 입은 사람을 보면 '오피스 드라마'를 제안하십시오. 답은 `[\"테마 1\", \"테마 2\", \"테마 3\"]`과 같은 간단한 JSON 문자열 배열로 반환하십시오. JSON 배열만 반환하십시오。"
    };
    return prompts[lang] || prompts['en']; // Default to English
};

const getGenerateIdeasSystemPrompt = (lang) => {
    const langInstructions = {
        'zh-TW': "一個簡短的、描述性的繁體中文 `id`（例如，'喝咖啡'，'打電動'）。這將是面向用戶的名稱。",
        'zh-CN': "一个简短的、描述性的简体中文 `id`（例如，'喝咖啡'，'打电动'）。这将是面向用户的名称。",
        'en': "A short, descriptive `id` in English (e.g., 'Drinking Coffee', 'Gaming'). This will be the user-facing name.",
        'ja': "短く説明的な日本語の `id`（例：「コーヒーを飲む」、「ゲーム中」）。これがユーザー向けの名称になります。",
        'ko': "짧고 설명적인 한국어 `id` (예: '커피 마시기', '게임하기'). 이것이 사용자에게 표시될 이름입니다."
    };

    return `You are a creative assistant that generates fun and expressive chat sticker ideas. Based on the user's description, provide a list of 6 to 8 sticker ideas. Each idea MUST include:
1. ${langInstructions[lang] || langInstructions['en']}
2. A detailed \`base\` prompt in English for an image generation model (e.g., 'happily sipping a large mug of coffee, looking energized').
3. A short, catchy, English \`memeText\` (e.g., 'COFFEE!', 'GAME ON').

Your response MUST be a valid JSON array of objects, following this exact schema. Do not include any other text or markdown formatting.`;
};


// --- 圖示 ---
const IconUpload = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-10 h-10"><path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" /></svg>;
const IconSparkles = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.259 8.715 18 9.75l-.259-1.035a3.375 3.375 0 0 0-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 0 0 2.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 0 0 2.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 0 0-2.456 2.456ZM16.894 20.567 16.5 21.75l-.394-1.183a2.25 2.25 0 0 0-1.423-1.423L13.5 18.75l1.183-.394a2.25 2.25 0 0 0 1.423-1.423l.394-1.183.394 1.183a2.25 2.25 0 0 0 1.423 1.423l1.183.394-1.183.394a2.25 2.25 0 0 0-1.423 1.423Z" /></svg>;
const IconDownload = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5"><path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>;
const IconCamera = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M6.827 6.175A2.31 2.31 0 0 1 5.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 0 0-1.134-.175 2.31 2.31 0 0 1-1.64-1.055l-.822-1.316a2.192 2.192 0 0 0-1.736-1.039 48.776 48.776 0 0 0-5.232 0 2.192 2.192 0 0 0-1.736 1.039l-.821 1.316Z" /><path strokeLinecap="round" strokeLinejoin="round" d="M16.5 12.75a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0ZM18.75 10.5h.008v.008h-.008V10.5Z" /></svg>;
const IconZip = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M20.25 7.5l-.625 10.632a2.25 2.25 0 01-2.247 2.118H6.622a2.25 2.25 0 01-2.247-2.118L3.75 7.5M10 11.25h4M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v1.5c0 .621.504 1.125 1.125 1.125z" /></svg>;
const IconGlobe = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M12 21a9.004 9.004 0 008.716-6.747M12 21a9.004 9.004 0 01-8.716-6.747M12 21c2.485 0 4.5-4.03 4.5-9S14.485 3 12 3m0 18c-2.485 0-4.5-4.03-4.5-9S9.515 3 12 3m0 0a8.997 8.997 0 017.843 4.582M12 3a8.997 8.997 0 00-7.843 4.582m15.686 0A11.953 11.953 0 0112 10.5c-2.998 0-5.74-1.1-7.843-2.918m15.686 0A8.959 8.959 0 0121 12c0 .778-.099 1.533-.284 2.253m0 0A17.919 17.919 0 0112 16.5c-3.162 0-6.133-.815-8.716-2.247m0 0A9.015 9.015 0 013 12c0-1.605.42-3.113 1.157-4.418" /></svg>


// --- React 元件 ---

const Button = ({ children, onClick, disabled, primary = false, className = '' }) => {
    const baseClass = "px-6 py-2 rounded-md font-semibold tracking-wider uppercase transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed";
    const themeClass = primary ? "bg-yellow-400 text-black hover:bg-yellow-300" : "bg-transparent border border-gray-600 text-gray-300 hover:bg-gray-800 hover:text-white";
    return <button onClick={onClick} disabled={disabled} className={`${baseClass} ${themeClass} ${className}`}>{children}</button>;
};

const ToggleSwitch = ({ id, checked, onChange, label }) => (
    <div className="flex items-center">
        <label htmlFor={id} className="flex items-center cursor-pointer">
            <div className="relative">
                <input id={id} type="checkbox" className="sr-only" checked={checked} onChange={onChange} />
                <div className={`block w-14 h-8 rounded-full transition-colors ${checked ? 'bg-yellow-400' : 'bg-gray-700'}`}></div>
                <div className={`dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition-transform duration-300 ease-in-out ${checked ? 'transform translate-x-6' : ''}`}></div>
            </div>
            <div className="ml-3 text-gray-300 select-none">{label}</div>
        </label>
    </div>
);

const StickerDisplay = ({ emotion, imageUrl, onDownload, onRegenerate, isDynamic, isProcessed = false }) => (
    <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }} whileHover={isDynamic ? { y: -8, rotate: Math.random() * 6 - 3 } : {}} className="relative group p-4 bg-gray-900/50 rounded-xl shadow-lg transition-all duration-300 hover:shadow-2xl border border-gray-800">
        <div className="aspect-square bg-grid-pattern flex items-center justify-center rounded-lg relative">
            <img src={imageUrl} alt={`Sticker for ${emotion}`} className="w-full h-full object-contain" />
            {isProcessed && <div className="absolute top-2 left-2 bg-green-500 text-white text-xs px-2 py-1 rounded-full font-semibold">透明背景</div>}
        </div>
        <p className="text-center mt-3 text-lg font-semibold text-gray-300 px-3">{emotion}</p>
        <div className="absolute top-3 right-3 z-10 opacity-0 group-hover:opacity-100 transition-opacity flex gap-2">
            <button onClick={onRegenerate} className="p-2 rounded-full bg-black/60 text-white hover:bg-black/80 transition-colors backdrop-blur-sm shadow-lg" aria-label="Regenerate sticker"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5"><path strokeLinecap="round" strokeLinejoin="round" d="M16.023 16.023A7.5 7.5 0 1 0 8.25 8.25V6.75a.75.75 0 0 1 1.5 0v3.75a.75.75 0 0 1-.75.75H5.25a.75.75 0 0 1 0-1.5h2.37a5.98 5.98 0 0 1 8.403 8.403Z" /></svg></button>
            <button onClick={() => onDownload(imageUrl, emotion)} className="p-2 rounded-full bg-black/60 text-white hover:bg-black/80 transition-colors backdrop-blur-sm shadow-lg" aria-label="Download sticker"><IconDownload /></button>
        </div>
    </motion.div>
);

const SkeletonLoader = ({ className }) => <div className={`animate-pulse bg-gray-800 ${className}`}></div>;

const LoadingCard = ({ emotion }) => (
    <div className="p-4 bg-gray-900 rounded-xl shadow-md">
        <div className="aspect-square bg-grid-pattern rounded-lg relative flex items-center justify-center"><div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-yellow-400"></div></div>
        <div className="mt-3 flex justify-center"><SkeletonLoader className="h-5 w-1/2 rounded-md" /></div>
    </div>
);

const ErrorCard = ({ emotion, onRegenerate }) => (
    <div className="p-4 bg-gray-900 rounded-xl shadow-md border border-red-500/30">
        <div className="aspect-square bg-grid-pattern rounded-lg flex flex-col items-center justify-center text-center p-4 border-2 border-dashed border-red-500/50">
            <p className="text-red-400 font-medium mb-4">生成失敗</p>
            {onRegenerate && <Button onClick={onRegenerate} primary>重試</Button>}
        </div>
        <p className="text-center mt-3 text-lg font-semibold text-gray-300 px-3">{emotion}</p>
    </div>
);

const ErrorNotification = ({ message, onDismiss }) => {
    if (!message) return null;
    return (
        <div className="fixed top-5 left-1/2 z-50 w-full max-w-md p-4 bg-gray-900 border border-gray-700 text-gray-300 rounded-lg shadow-2xl flex items-center justify-between animate-fade-in-down" style={{ transform: 'translateX(-50%)' }}>
            <span>{message}</span>
            <button onClick={onDismiss} className="p-1 rounded-full hover:bg-gray-800 transition-colors ml-4"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-500"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>
        </div>
    );
};

const CameraModal = ({ isOpen, onClose, onCapture }) => {
    const videoRef = useRef(null);
    const canvasRef = useRef(null);
    const streamRef = useRef(null);
    const [capturedImage, setCapturedImage] = useState(null);
    const [cameraError, setCameraError] = useState(null);
    const stopCamera = useCallback(() => { if (streamRef.current) { streamRef.current.getTracks().forEach(track => track.stop()); streamRef.current = null; } if (videoRef.current) videoRef.current.srcObject = null; }, []);
    const startCamera = useCallback(async () => { if (videoRef.current) { setCameraError(null); try { stopCamera(); const stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 1024 }, height: { ideal: 1024 }, facingMode: 'user' } }); videoRef.current.srcObject = stream; streamRef.current = stream; } catch (err) { setCameraError("相機存取被拒絕。請在您的瀏覽器設定中允許相機存取。"); } } }, [stopCamera]);
    useEffect(() => { if (isOpen && !capturedImage) startCamera(); else stopCamera(); return stopCamera; }, [isOpen, capturedImage, startCamera, stopCamera]);
    const handleCapture = () => { if (videoRef.current && canvasRef.current) { const video = videoRef.current, canvas = canvasRef.current; canvas.width = video.videoWidth; canvas.height = video.videoHeight; const context = canvas.getContext('2d'); context.scale(-1, 1); context.drawImage(video, -canvas.width, 0, canvas.width, canvas.height); setCapturedImage(canvas.toDataURL('image/png')); } };
    const handleConfirm = () => { if (capturedImage) { onCapture(capturedImage); onClose(); } };
    if (!isOpen) return null;
    return (
        <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4">
            <motion.div initial={{ opacity: 0, scale: 0.95 }} animate={{ opacity: 1, scale: 1 }} transition={{ duration: 0.2 }} className="bg-gray-900 rounded-2xl p-6 border border-gray-700 shadow-2xl w-full max-w-2xl text-center relative">
                <h3 className="text-2xl font-semibold mb-4 text-white">相機</h3>
                <div className="aspect-square bg-black rounded-lg overflow-hidden relative mb-4 flex items-center justify-center">{cameraError ? <div className="p-4 text-red-400">{cameraError}</div> : <>{capturedImage ? <img src={capturedImage} alt="拍攝預覽" className="w-full h-full object-cover" /> : <video ref={videoRef} autoPlay playsInline className="w-full h-full object-cover transform -scale-x-100"></video>}</>}</div>
                <div className="flex justify-center gap-4">{capturedImage ? <><Button onClick={() => setCapturedImage(null)}>重拍</Button><Button onClick={handleConfirm} primary>使用照片</Button></> : <button onClick={handleCapture} disabled={!!cameraError} className="w-20 h-20 rounded-full bg-white border-4 border-gray-600 focus:outline-none focus:ring-4 focus:ring-yellow-400 transition-all hover:border-yellow-400 disabled:opacity-50 disabled:cursor-not-allowed"></button>}</div>
                <button onClick={onClose} className="absolute top-4 right-4 p-2 rounded-full bg-gray-800/70 text-white hover:bg-gray-700 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M6 18 18 6M6 6l12 12" /></svg></button>
                <canvas ref={canvasRef} className="hidden"></canvas>
            </motion.div>
        </div>
    );
};

const LanguageSwitcher = ({ language, setLanguage }) => {
    const [isOpen, setIsOpen] = useState(false);
    const languages = { 'zh-TW': '繁體中文', 'zh-CN': '简体中文', 'en': 'English', 'ja': '日本語', 'ko': '한국어' };
    const ref = useRef(null);

    useEffect(() => {
        const handleClickOutside = (event) => {
            if (ref.current && !ref.current.contains(event.target)) setIsOpen(false);
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    return (
        <div ref={ref} className="relative">
            <button onClick={() => setIsOpen(!isOpen)} className="flex items-center gap-2 text-gray-400 hover:text-white transition-colors">
                <IconGlobe />
                <span className="hidden md:inline">{languages[language]}</span>
            </button>
            {isOpen && (
                <div className="absolute top-full right-0 mt-2 w-40 bg-gray-800 border border-gray-700 rounded-md shadow-lg z-20">
                    {Object.entries(languages).map(([code, name]) => (
                        <button key={code} onClick={() => { setLanguage(code); setIsOpen(false); }} className="w-full text-left px-4 py-2 text-sm text-gray-300 hover:bg-gray-700">
                            {name}
                        </button>
                    ))}
                </div>
            )}
        </div>
    );
};

const AppFooter = ({ t }) => {
    const [links, setLinks] = useState({ gamePortals: [], communityLinks: [], chatroomLinks: [] });
    const [activeModal, setActiveModal] = useState(null);

    useEffect(() => {
        const fetchLinks = async () => {
            try {
                const response = await fetch("https://callmygod.com/api/app_links.php");
                if (!response.ok) throw new Error("Network response was not ok");
                const data = await response.json();
                setLinks(data);
            } catch (error) {
                console.error("Failed to fetch app links:", error);
            }
        };
        fetchLinks();
    }, []);

    const FooterModal = ({ type, onClose }) => {
        const isGamePortals = type === 'gamePortals';
        const data = links[type] || [];
        const title = isGamePortals ? t('footer_portals') : t('footer_resources');

        return (
            <div className="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm flex items-center justify-center p-4 z-50" onClick={onClose}>
                <div className="w-full max-w-4xl bg-slate-900 border border-slate-700 rounded-2xl shadow-xl max-h-[90vh] flex flex-col transform" onClick={e => e.stopPropagation()}>
                    <header className="flex items-center justify-between p-4 border-b border-slate-800 flex-shrink-0">
                        <h2 className="text-xl font-bold text-cyan-300">{title}</h2>
                        <button onClick={onClose} className="text-gray-400 hover:text-white transition-colors"><svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" /></svg></button>
                    </header>
                    <div className="p-6 sm:p-8 overflow-y-auto grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                        {isGamePortals ? data.map(portal => (
                             <a key={portal.id} href={portal.url} target="_blank" rel="noopener noreferrer" className="portal-button group rounded-xl p-6 flex flex-col justify-between h-48 bg-gray-800/80 border border-gray-700 hover:border-cyan-400 hover:shadow-cyan-400/30">
                                <div>
                                    <h2 className={`text-2xl font-bold transition-colors ${portal.colorClasses?.[0] || 'text-white'} ${portal.colorClasses?.[1] || 'group-hover:text-white'}`}>{portal.title}</h2>
                                    <p className="text-gray-400 mt-2">{portal.description}</p>
                                </div>
                                <span className="text-right text-cyan-400 font-semibold opacity-70 group-hover:opacity-100 transition-opacity">→ 立即進入</span>
                            </a>
                        )) : data.map(link => (
                            <a key={link.id} href={link.url} target="_blank" rel="noopener noreferrer" className="community-link p-4 rounded-lg flex items-center gap-4 bg-slate-800/90 border border-slate-700 hover:border-sky-400 hover:bg-sky-400/10">
                                <span className="text-2xl">{link.emoji}</span><span className="font-semibold">{link.name}</span>
                            </a>
                        ))}
                    </div>
                </div>
            </div>
        );
    };

    const chatLink = links.chatroomLinks?.[0];

    return (
        <footer className="mt-20 mb-8">
            <div className="text-center flex flex-col items-center justify-center gap-6">
                <div className="flex flex-row items-center justify-center gap-4 sm:gap-6">
                    <button onClick={() => setActiveModal('gamePortals')} className="portal-button text-lg sm:text-xl font-bold py-3 px-6 sm:px-8 rounded-lg hover:border-fuchsia-400 hover:shadow-fuchsia-400/30">{t('footer_portals')}</button>
                    <button onClick={() => setActiveModal('communityLinks')} className="portal-button text-lg sm:text-xl font-bold py-3 px-6 sm:px-8 rounded-lg hover:border-sky-400 hover:shadow-sky-400/30">{t('footer_resources')}</button>
                </div>
                {chatLink && (
                    <a href={chatLink.url} target="_blank" rel="noopener noreferrer" className="portal-button chatroom-button text-xl sm:text-2xl font-bold py-4 px-10 rounded-lg inline-block">
                        <span className="mr-2">{chatLink.emoji}</span><span>{t('footer_chat')}</span>
                    </a>
                )}
            </div>
            {activeModal && <FooterModal type={activeModal} onClose={() => setActiveModal(null)} />}
        </footer>
    );
};

const App = () => {
    const [language, setLanguage] = useState('zh-TW');
    const t = useCallback((key) => {
        const currentLangTranslation = translations[language]?.[key];
        if (currentLangTranslation) return currentLangTranslation;
        const englishTranslation = translations['en']?.[key];
        if (englishTranslation) return englishTranslation;
        return key;
    }, [language]);

    const [uploadedImage, setUploadedImage] = useState(null);
    const [generatedImages, setGeneratedImages] = useState([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    const fileInputRef = useRef(null);
    const [isUploading, setIsUploading] = useState(false);
    const [isCameraOpen, setIsCameraOpen] = useState(false);
    const resultsRef = useRef(null);
    const [isRemovingBackground, setIsRemovingBackground] = useState(false);
    const [removeBgProgress, setRemoveBgProgress] = useState(0);
    const [processedImages, setProcessedImages] = useState([]);
    const [selectedStickers, setSelectedStickers] = useState([]);
    const [isAnimeStyle, setIsAnimeStyle] = useState(false);
    const [addText, setAddText] = useState(true);
    const [isDynamic, setIsDynamic] = useState(true);
    const [isZipping, setIsZipping] = useState(false);
    const [customIdeaInput, setCustomIdeaInput] = useState('');
    const [customStickerPack, setCustomStickerPack] = useState([]);
    const [isGeneratingIdeas, setIsGeneratingIdeas] = useState(false);
    const [suggestedThemes, setSuggestedThemes] = useState([]);
    const [isSuggestingThemes, setIsSuggestingThemes] = useState(false);

    const defaultStickerPack = useMemo(() => ({
        prompts: [
            { id: 'sticker_happy', base: 'a happy, joyful, smiling expression, maybe with stars in the eyes', memeText: 'YAY!' }, 
            { id: 'sticker_sad', base: 'a sad expression, with cartoonishly large tears streaming down the face', memeText: 'SO SAD' }, 
            { id: 'sticker_laugh', base: 'laughing out loud hysterically, eyes squeezed shut', memeText: 'LOL' }, 
            { id: 'sticker_angry', base: 'an angry, fuming expression with red cheeks and steam coming out of the ears', memeText: 'GRRR' }, 
            { id: 'sticker_love', base: 'an adoring expression with large heart-shaped eyes', memeText: 'UWU' }, 
            { id: 'sticker_ok', base: 'giving a cheerful thumbs-up sign', memeText: 'OK!' }, 
            { id: 'sticker_confused', base: 'a confused expression with question marks floating around the head', memeText: '???' }, 
            { id: 'sticker_sleepy', base: 'a very sleepy, yawning expression with a snot bubble', memeText: 'Zzz...' }, 
            { id: 'sticker_surprised', base: 'a shocked, surprised expression with wide eyes and open mouth, like "wow"', memeText: 'WOW!' }, 
            { id: 'sticker_thinking', base: 'a thoughtful expression with a finger on the chin, looking upwards', memeText: 'Hmm...' }, 
            { id: 'sticker_crying', base: 'a crying expression with a quivering lip, feeling wronged', memeText: 'SNIFF...' }, 
            { id: 'sticker_pleading', base: 'a pleading expression with big, shimmering "puppy dog" eyes', memeText: 'Pls?' },
        ]
    }), []);

    const apiUrl = 'https://callmygod.com/api/game_check.php?game=52';

    // 使用 fetch 函數發送 GET 請求
    fetch(apiUrl)
        .then(response => {
            // 檢查伺服器回應是否成功 (例如 HTTP 狀態碼 200)
            if (!response.ok) {
                // 如果伺服器回傳錯誤 (如 404, 500), 拋出一個錯誤
                throw new Error('Network response was not ok: ' + response.statusText);
            }
            // 將回應的內容解析為 JSON 格式
            return response.json();
        })
        .then(data => {
            // 成功獲取 API 回應的 JSON 資料
            console.log('API 調用成功:', data);
            // 你可以在這裡根據 API 的回應做一些額外操作
            // 例如：if (data.status === 'success') { ... }
        })
        .catch(error => {
            // 捕獲任何在請求過程中發生的錯誤 (例如網路中斷、CORS 錯誤等)
            console.error('API 調用失敗:', error);
        });
    
    const activeStickerPack = customStickerPack.length > 0 ? customStickerPack : defaultStickerPack.prompts;

    useEffect(() => {
        setSelectedStickers(defaultStickerPack.prompts.map(p => p.id));
        const script = document.createElement('script');
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
        script.async = true;
        document.body.appendChild(script);
        return () => { document.body.removeChild(script); };
    }, [defaultStickerPack]);

    const handleStickerSelection = (stickerId) => setSelectedStickers(prev => prev.includes(stickerId) ? prev.filter(id => id !== stickerId) : [...prev, stickerId]);

    const regenerateImageAtIndex = async (imageIndex) => {
        const imageToRegenerate = generatedImages[imageIndex];
        if (!imageToRegenerate) return;
        setGeneratedImages(prev => prev.map((img, index) => index === imageIndex ? { ...img, status: 'pending' } : img));
        setError(null);
        const originalPrompts = activeStickerPack.filter(p => generatedImages.map(gi => gi.id).includes(p.id));
        const prompt = originalPrompts[imageIndex];
        if (!prompt) { setError(t('error_no_prompt_found')); setGeneratedImages(prev => prev.map((img, index) => index === imageIndex ? { ...img, status: 'failed' } : img)); return; }
        try {
            const imageWithoutPrefix = uploadedImage.split(',')[1];
            const modelInstruction = getModelInstruction(prompt, addText, isAnimeStyle);
            const payload = { contents: [{ parts: [{ text: modelInstruction }, { inlineData: { mimeType: "image/png", data: imageWithoutPrefix } }] }] };
            const imageUrl = await generateImageWithRetry(payload);
            setGeneratedImages(prev => prev.map((img, index) => index === imageIndex ? { ...img, status: 'success', imageUrl } : img));
        } catch (err) {
            setError(t('error_regenerate_failed').replace('{stickerName}', t(prompt.id)));
            setGeneratedImages(prev => prev.map((img, index) => index === imageIndex ? { ...img, status: 'failed' } : img));
        }
    };
    
    const handleImageUpload = async (event) => {
        const file = event.target.files[0];
        if (file) {
            setIsUploading(true);
            setError(null);
            try {
                const base64Image = await toBase64(file);
                setUploadedImage(base64Image);
                setGeneratedImages([]); setSuggestedThemes([]);
            } catch (err) { setError(t('error_file_process')); }
            finally { setIsUploading(false); }
        }
    };
    
    const handleCaptureConfirm = (imageDataUrl) => { setUploadedImage(imageDataUrl); setGeneratedImages([]); setError(null); setSuggestedThemes([]); };

    const handleGenerateClick = async () => {
        if (!uploadedImage) { setError(t('error_upload')); return; }
        if (selectedStickers.length === 0) { setError(t('error_select_one')); return; }
        setIsLoading(true); setError(null); setGeneratedImages([]);
        setTimeout(() => { resultsRef.current?.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 100);
        const imageWithoutPrefix = uploadedImage.split(',')[1];
        const promptsForGeneration = activeStickerPack.filter(p => selectedStickers.includes(p.id));
        setGeneratedImages(promptsForGeneration.map(p => ({ id: p.id, status: 'pending', imageUrl: null })));
        
        for (let i = 0; i < promptsForGeneration.length; i++) {
            const p = promptsForGeneration[i];
            const promptData = activeStickerPack.find(item => item.id === p.id);
            if(!promptData) continue;

            try {
                const modelInstruction = getModelInstruction(promptData, addText, isAnimeStyle);
                const payload = { contents: [{ parts: [{ text: modelInstruction }, { inlineData: { mimeType: "image/png", data: imageWithoutPrefix } }] }] };
                const imageUrl = await generateImageWithRetry(payload);
                setGeneratedImages(prev => prev.map(img => img.id === p.id ? { ...img, status: 'success', imageUrl } : img));
            } catch (err) {
                setGeneratedImages(prev => prev.map(img => img.id === p.id ? { ...img, status: 'failed' } : img));
            }
        }
        setIsLoading(false);
    };

    const triggerDownload = (href, fileName) => { const link = document.createElement('a'); link.href = href; link.download = fileName; document.body.appendChild(link); link.click(); document.body.removeChild(link); };
    const handleDownloadRequest = (imageUrl, emotionId, isProcessed = false) => { const suffix = isProcessed ? '-transparent' : ''; const fileName = `sticker-${emotionId.toLowerCase().replace(/\s+/g, '-')}${suffix}.png`; triggerDownload(imageUrl, fileName); };

    const handleDownloadAllAsZip = async () => {
        if (isZipping || typeof window.JSZip === 'undefined') { if (typeof window.JSZip === 'undefined') setError(t('error_zip_lib')); return; }
        setIsZipping(true); setError(null);
        try {
            const zip = new window.JSZip();
            const imagesToPack = processedImages.length > 0 ? processedImages : generatedImages.filter(img => img.status === 'success');
            if (imagesToPack.length === 0) { setError(t('error_no_stickers_to_zip')); return; }
            await Promise.all(imagesToPack.map(async (img) => {
                const imageUrl = img.processedImageUrl || img.imageUrl;
                const response = await fetch(imageUrl); const blob = await response.blob();
                const suffix = img.isProcessed ? '-transparent' : ''; const fileName = `sticker-${img.id.toLowerCase().replace(/\s+/g, '-')}${suffix}.png`;
                zip.file(fileName, blob);
            }));
            const content = await zip.generateAsync({ type: "blob" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(content);
            link.download = processedImages.length > 0 ? "ai-sticker-pack-transparent.zip" : "ai-sticker-pack.zip";
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        } catch (err) { setError(t('error_zip_failed')); }
        finally { setIsZipping(false); }
    };
    
    const handleStartOver = () => { setGeneratedImages([]); setUploadedImage(null); setError(null); setCustomStickerPack([]); setCustomIdeaInput(''); setSuggestedThemes([]); setSelectedStickers(defaultStickerPack.prompts.map(p => p.id)); setProcessedImages([]); setRemoveBgProgress(0); window.scrollTo({ top: 0, behavior: 'smooth' }); };

    const handleRemoveBackground = async () => {
        const successfulImages = generatedImages.filter(img => img.status === 'success');
        if (successfulImages.length === 0) { setError(t('error_no_stickers_to_process')); return; }
        setIsRemovingBackground(true); setRemoveBgProgress(0); setError(null); setProcessedImages([]);
        try {
            const processedResults = [];
            for (let i = 0; i < successfulImages.length; i++) {
                const img = successfulImages[i];
                try {
                    processedResults.push({ ...img, processedImageUrl: await removeBackground(img.imageUrl), isProcessed: true });
                } catch (err) { processedResults.push({ ...img, processedImageUrl: img.imageUrl, isProcessed: false }); }
                setRemoveBgProgress(((i + 1) / successfulImages.length) * 100);
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            setProcessedImages(processedResults);
        } catch (err) { setError(t('error_bg_remove_failed')); }
        finally { setIsRemovingBackground(false); }
    };

    const handleGenerateIdeas = async () => {
        if (!customIdeaInput.trim()) { setError(t('error_ideas_input')); return; }
        setIsGeneratingIdeas(true); setError(null); setCustomStickerPack([]); setSuggestedThemes([]);
        const apiKey = ""; const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
        const systemPrompt = getGenerateIdeasSystemPrompt(language);
        const payload = { contents: [{ parts: [{ text: customIdeaInput }] }], systemInstruction: { parts: [{ text: systemPrompt }] }, generationConfig: { responseMimeType: "application/json", responseSchema: { type: "ARRAY", items: { type: "OBJECT", properties: { "id": { "type": "STRING" }, "base": { "type": "STRING" }, "memeText": { "type": "STRING" } }, required: ["id", "base", "memeText"] } } } };
        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
            const result = await response.json(); const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (jsonText) { const ideas = JSON.parse(jsonText); setCustomStickerPack(ideas); setSelectedStickers(ideas.map(idea => idea.id)); } else throw new Error("API did not return valid JSON content.");
        } catch (err) { setError(t('error_ideas_failed')); }
        finally { setIsGeneratingIdeas(false); }
    };
    
    const handleGetInspirationFromImage = async () => {
        if (!uploadedImage) { setError(t('error_upload')); return; }
        setIsSuggestingThemes(true); setError(null); setSuggestedThemes([]);
        const apiKey = ""; const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
        const imageWithoutPrefix = uploadedImage.split(',')[1];
        const textPrompt = getInspirationPrompt(language);
        const payload = { contents: [{ parts: [{ text: textPrompt }, { inlineData: { mimeType: "image/png", data: imageWithoutPrefix } }] }], generationConfig: { responseMimeType: "application/json", responseSchema: { type: "ARRAY", items: { type: "STRING" } } } };
        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
            const result = await response.json(); const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (jsonText) setSuggestedThemes(JSON.parse(jsonText)); else throw new Error("API did not return valid theme suggestions.");
        } catch(err) { setError(t('error_inspiration_failed')); }
        finally { setIsSuggestingThemes(false); }
    };

    const progress = generatedImages.length > 0 ? (generatedImages.filter(img => img.status !== 'pending').length / generatedImages.length) * 100 : 0;
    
    return (
        <>
            <style>{`
              @import url('https://fonts.googleapis.com/css2?family=Caveat:wght@700&family=Inter:wght@400;500;600;700;900&display=swap');
              body { font-family: 'Inter', sans-serif; background-color: #000000; }
              .bg-grid-pattern { background-image: linear-gradient(rgba(255,255,255,0.07) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.07) 1px, transparent 1px); background-size: 20px 20px; }
              @keyframes fade-in-down { 0% { opacity: 0; transform: translateY(-20px) translateX(-50%); } 100% { opacity: 1; transform: translateY(0) translateX(-50%); } }
              .animate-fade-in-down { animation: fade-in-down 0.5s ease-out forwards; }
              .portal-button { background-color: rgba(17, 24, 39, 0.8); border: 1px solid rgba(55, 65, 81, 0.8); backdrop-filter: blur(8px); transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
              .portal-button:hover { transform: translateY(-5px); }
              .community-link { transition: all 0.2s ease-in-out; }
              .community-link:hover { transform: scale(1.05); }
              .chatroom-button { background-image: linear-gradient(to right, #6d28d9, #be185d); animation: pulse-glow 2.5s infinite; }
              @keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 20px rgba(192, 132, 252, 0.4); } 50% { box-shadow: 0 0 35px rgba(192, 132, 252, 0.8); } }
            `}</style>
            
            <CameraModal isOpen={isCameraOpen} onClose={() => setIsCameraOpen(false)} onCapture={handleCaptureConfirm} />

            <div className="bg-black text-gray-200 min-h-screen flex flex-col items-center p-4 pb-20">
                 <ErrorNotification message={error} onDismiss={() => setError(null)} />
                
                <div className="w-full max-w-6xl mx-auto">
                    <header className="text-center my-12 relative">
                        <div className="absolute top-0 right-0">
                            <LanguageSwitcher language={language} setLanguage={setLanguage} />
                        </div>
                        <h1 className="text-6xl md:text-7xl font-bold text-white tracking-tight">
                            {t('title')}
                        </h1>
                        <p className="mt-4 text-lg text-gray-500">{t('subtitle')}</p>
                    </header>

                    <main>
                        <div className="bg-gray-900/50 backdrop-blur-sm p-8 rounded-2xl shadow-2xl border border-gray-800 mb-16">
                            <div className="grid grid-cols-1 lg:grid-cols-2 gap-10">
                                <div>
                                    <h2 className="text-2xl font-semibold mb-6 text-white">{t('upload_title')}</h2>
                                    <div className="w-full aspect-square border-4 border-dashed border-gray-700 rounded-xl flex items-center justify-center cursor-pointer hover:border-yellow-400 transition-colors bg-gray-800 overflow-hidden shadow-inner" onClick={() => !uploadedImage && fileInputRef.current?.click()}>
                                        {isUploading ? <div className="flex flex-col items-center"><div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-yellow-400"></div><p className="text-gray-400 mt-4">{t('generating')}</p></div> : uploadedImage ? <img src={uploadedImage} alt="上傳預覽" className="w-full h-full object-cover" /> : <div className="flex flex-col items-center justify-center p-6 text-center text-gray-500"><IconUpload /><p className="mt-4 text-lg text-gray-300">{t('upload_click')}</p><p className="mt-4 text-sm">{t('upload_or')}</p><Button onClick={(e) => { e.stopPropagation(); setIsCameraOpen(true); }} className="mt-2"><div className="flex items-center gap-2"><IconCamera /><span>{t('upload_camera')}</span></div></Button></div>}
                                    </div>
                                    {uploadedImage && !isUploading && (<div className="flex flex-col sm:flex-row gap-4 mt-4 w-full"><Button onClick={() => fileInputRef.current?.click()} className="flex-1">{t('upload_change_file')}</Button><Button onClick={() => setIsCameraOpen(true)} className="flex-1"><div className="flex items-center justify-center gap-2"><IconCamera /><span>{t('upload_camera')}</span></div></Button></div>)}
                                    <input type="file" ref={fileInputRef} onChange={handleImageUpload} accept="image/png, image/jpeg" className="hidden" />
                                </div>
                                <div>
                                     <h2 className="text-2xl font-semibold mb-6 text-white">{t('stickers_title')}</h2>
                                     <div className="bg-gray-800/50 p-4 rounded-lg border border-gray-700 mb-6">
                                        <h3 className="font-semibold text-lg mb-2 text-yellow-300">{t('generator_title')}</h3><p className="text-gray-400 text-sm mb-3">{t('generator_desc')}</p>
                                        <div className="mb-3"><Button onClick={handleGetInspirationFromImage} disabled={!uploadedImage || isSuggestingThemes} className="w-full"><div className="flex items-center justify-center gap-2">{isSuggestingThemes ? <><div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-gray-300"></div><span>{t('generator_analyzing')}</span></> : <><IconSparkles /><span>{t('generator_inspiration_btn')}</span></>}</div></Button>{suggestedThemes.length > 0 && (<div className="flex flex-wrap gap-2 mt-3">{suggestedThemes.map(theme => (<button key={theme} onClick={() => { setCustomIdeaInput(theme); handleGenerateIdeas(); }} className="px-3 py-1 bg-gray-700 text-sm rounded-full hover:bg-gray-600">{theme}</button>))}</div>)}</div>
                                        <textarea value={customIdeaInput} onChange={(e) => setCustomIdeaInput(e.target.value)} placeholder={t('generator_placeholder')} className="w-full bg-gray-900 border border-gray-600 rounded-lg py-2 px-3 focus:outline-none focus:ring-2 focus:ring-yellow-400 text-white text-sm" rows="2" />
                                        <Button onClick={handleGenerateIdeas} disabled={isGeneratingIdeas} primary className="w-full mt-3"><div className="flex items-center justify-center gap-2">{isGeneratingIdeas ? <><div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-black"></div><span>{t('generator_generating')}</span></> : t('generator_generate_ideas_btn')}</div></Button>
                                     </div>
                                      <div className="flex justify-between items-center mb-4"><p className="text-gray-400">{t('select_reactions')}</p>{customStickerPack.length > 0 && (<button onClick={() => { setCustomStickerPack([]); setSelectedStickers(defaultStickerPack.prompts.map(p => p.id)); }} className="text-xs text-yellow-400 hover:text-yellow-300">{t('back_to_default')}</button>)}</div>
                                      <div className="grid grid-cols-2 sm:grid-cols-3 gap-3">
                                         {activeStickerPack.map(prompt => (<label key={prompt.id} className={`cursor-pointer p-3 rounded-lg border-2 text-center transition-colors duration-200 ${selectedStickers.includes(prompt.id) ? 'bg-yellow-400/20 border-yellow-400 text-white' : 'bg-gray-800 border-gray-700 hover:border-gray-600 text-gray-300'}`}><input type="checkbox" checked={selectedStickers.includes(prompt.id)} onChange={() => handleStickerSelection(prompt.id)} className="hidden" /><span className="font-semibold text-sm">{t(prompt.id)}</span></label>))}
                                     </div>
                                      <div className="flex flex-col sm:flex-row items-start sm:items-center gap-4 mt-6">
                                         <ToggleSwitch id="isAnimeStyleCheck" checked={isAnimeStyle} onChange={(e) => setIsAnimeStyle(e.target.checked)} label={t('option_anime')} />
                                         <ToggleSwitch id="addTextCheck" checked={addText} onChange={(e) => setAddText(e.target.checked)} label={t('option_add_text')} />
                                         <ToggleSwitch id="isDynamicCheck" checked={isDynamic} onChange={(e) => setIsDynamic(e.target.checked)} label={t('option_dynamic_preview')} />
                                      </div>
                                </div>
                            </div>
                            <div className="mt-12 text-center">
                                <div className="flex flex-col sm:flex-row items-center justify-center gap-4">
                                    <Button onClick={handleGenerateClick} disabled={!uploadedImage || isLoading || isUploading} primary className="text-lg px-12 py-4"><div className="flex items-center gap-3">{isLoading ? <><div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-black"></div>{`${t('generating_stickers')} (${Math.round(progress)}%)`}</> : <><IconSparkles />{t('generate_stickers_btn')}</>}</div></Button>
                                    {!isLoading && generatedImages.some(img => img.status === 'success') && (<div className="flex flex-col items-center gap-2"><Button onClick={handleRemoveBackground} disabled={isRemovingBackground} className="text-lg px-8 py-4 bg-green-600 hover:bg-green-500 text-white"><div className="flex items-center gap-3">{isRemovingBackground ? <><div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-white"></div>{`${t('removing_bg')} (${Math.round(removeBgProgress)}%)`}</> : <><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M9.53 16.122a3 3 0 0 0-5.78 1.128 2.25 2.25 0 0 1-2.4 2.245 4.5 4.5 0 0 0 8.4-2.245c0-.399-.078-.78-.22-1.128Zm0 0a15.998 15.998 0 0 0 3.388-1.62m-5.043-.025a15.994 15.994 0 0 1 1.622-3.395m3.42 3.42a15.995 15.995 0 0 0 4.764-4.648l3.876-3.876a1.5 1.5 0 0 0-4.471-4.471L9.53 16.122ZM21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" /></svg>{t('remove_bg_btn')}</>}</div ></Button><p className="text-xs text-gray-400 text-center max-w-xs">{t('remove_bg_desc')}</p></div>)}
                                </div>
                                {isRemovingBackground && (<div className="w-full max-w-md mx-auto mt-4"><div className="bg-gray-800 rounded-full h-3 overflow-hidden shadow-md"><motion.div className="bg-green-500 h-3 rounded-full" initial={{ width: 0 }} animate={{ width: `${removeBgProgress}%` }} transition={{ duration: 0.3 }} /></div><p className="text-gray-400 mt-2 text-sm">{t('removing_bg')}...</p></div>)}
                            </div>
                        </div>
                        <div ref={resultsRef}>
                            {(isLoading || generatedImages.length > 0) && (
                                <div className="mt-16">
                                    <h2 className="text-3xl font-bold text-white mb-8 text-center">{t('your_generated_stickers')}</h2>
                                    {isLoading && (<div className="w-full max-w-4xl mx-auto mb-8 text-center"><div className="bg-gray-800 rounded-full h-3 overflow-hidden shadow-md"><motion.div className="bg-yellow-400 h-3 rounded-full" initial={{ width: 0 }} animate={{ width: `${progress}%` }} transition={{ duration: 0.5 }} /></div><p className="text-gray-400 mt-4 text-sm">{t('keep_window_open')}</p></div>)}
                                     <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-6 mt-8">
                                        {generatedImages.map((img, index) => {
                                            const emotionDisplay = t(img.id);
                                            switch (img.status) {
                                                case 'success': 
                                                    const processedImg = processedImages.find(p => p.id === img.id); 
                                                    const displayImageUrl = processedImg ? processedImg.processedImageUrl : img.imageUrl; 
                                                    const isProcessed = !!processedImg?.isProcessed; 
                                                    return <StickerDisplay key={`${img.id}-${index}-success`} emotion={emotionDisplay} imageUrl={displayImageUrl} onDownload={(url, emotion) => handleDownloadRequest(url, img.id, isProcessed)} onRegenerate={() => regenerateImageAtIndex(index)} isDynamic={isDynamic} isProcessed={isProcessed} />;
                                                case 'failed': 
                                                    return <ErrorCard key={`${img.id}-${index}-failed`} emotion={emotionDisplay} onRegenerate={() => regenerateImageAtIndex(index)} />;
                                                default: 
                                                    return <LoadingCard key={`${img.id}-${index}-pending`} emotion={emotionDisplay} />;
                                            }
                                        })}
                                    </div>
                                </div>
                            )}
                            {!isLoading && generatedImages.length > 0 && (<div className="text-center mt-16 mb-12 flex flex-col sm:flex-row items-center justify-center gap-6"><Button onClick={handleStartOver}>{t('start_over')}</Button><Button onClick={handleDownloadAllAsZip} primary disabled={isZipping}><div className="flex items-center gap-2">{isZipping ? <><div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-black"></div><span>{t('zipping')}</span></> : <><IconZip /><span>{t('download_zip')}</span></>}</div></Button></div>)}
                        </div>
                    </main>
                    <AppFooter t={t} />
                </div>
            </div>
        </>
    );
};

export default App;

